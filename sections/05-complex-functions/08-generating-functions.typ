#import "../../utils/core.typ": *

== Производящие функции

#remind(name: "произведение рядов")[
    Если $A(z) = sum_(n = 0)^oo a_n z^n$, и $B(z) = sum_(n = 0)^oo b_n z^n$. Тогда
    $
        A(z) B(z) = sum_(n = 0)^oo c_n z^n, "где" c_n = a_0 b_n + a_1 b_(n-1) + a_2 b_(n-2) + ... + a_n b_0.
    $
    $c_n$ --- свертка последовательностей $a_n$ и $b_n$.
]

#example(name: "Задача о размене")[
    Пусть у нас есть монетки номиналом $1$, $2$, $5$, и $10$, в неограниченом количестве. Сколькими способами можно разменять $n$ монеток?

    Если $a_n$ --- последовательность ответов, то можно записать следующую функцию, которая называется _производящей функцией последовательности_:
    $ A(z) = sum_(n = 0)^oo a_n z^n. $
    Естественно, мы хотим чтобы у этой функции был хоть какой-то радиус сходиомости, то есть чтобы коэффициенты не росли быстрее чем $O(n^c)$. Тогда,
    $
        A(z) = (1+z+z^2&+z^3+...) (1+z^2+z^4+z^6+...) \
        &(1+z^5+z^10+z^15+...) (1+z^10+z^20+z^30+...),
    $
    Тогда коэффициент при $z^n$ равен количеству способов разменять $n$ монеток, или количетсво способов представить $n$ в виде $a + 2b + 5c + 10d$. Можно свернуть геометрические прогрессии:
    $
        A(z) = 1/(1-z) dot 1/(1-z^2) dot 1/(1-z^5) dot 1/(1-z^10).
    $
]

#def[
    Пусть $H subset NN$. Обозначим $p(n, H)$ --- количество способов представить $n$ в виде суммы элементов из $H$.
]

#notice[
    $
        sum_(n = 0)^oo p(n, H) z^n = product_(k in H) 1/(1 - z^k).
    $
]

#notice[
    Если на каждое слагаемое есть ограничение на количество слагаемых ($<= r$ раз, скажем), то
    $
        Ff(z) = product_(k in H) 1/(1 + z^k + ... + z^(k r)) = product_(k in H) (1 - z^((r+1)k)) / (1 - z^k).
    $
]

#def[
    $p(n)$ --- число разбиений, то есть $p(n, NN)$.
]

#notice(name: "теорема Харди-Рамануджана")[
    $p(n) sim 1/(4n sqrt(3)) e^(pi sqrt(2/3) sqrt(n))$. Очев#footnote[нет].
]
